<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public class DataLayerGeneration : IDisposable
{
	private string _connectionString;

	public string UserSecretsId {get; set;}
    public string ProviderName { get; set; }
    public string ConnectionString 	{
		get
		{
			if (!string.IsNullOrEmpty(_connectionString)) return _connectionString;
			return GetConnectionStringFromSecrets();
		}
		set
		{
			_connectionString = value;
		}
	}
	public string ConnectionStringName {get; set;}

    public string RootNamespace { get; set; }
    public string DataServiceName { get; set; }
    public string ProceduresClassName { get; set; }
	public string DefaultSchema { get; set;}
    public bool GenerateEntityTypeId { get; set; }
	public bool GenerateDataContractAttributes {get; set;} = true;
	public bool GenerateMessagePackAttributes {get; set;} = false;
	public TextTransform EntityNameToEntityViewTransform {get; set;}
	public bool ImplementINotifyPropertyChanged {get; set;}
	public bool GenerateTypeScript { get; set;}
	public bool GenerateAsyncMethods {get; set;}
	public bool GenerateProjectionColumnLists {get; set;}

	public string EntityTypesTableName {get; set;}
	public string EntityTypeNameColumnName {get; set;}

	public DateTimeKind AuditDateTimeKind {get; set;}

    public List<EntitySetting> EntitySettings { get; set; }
    public List<ProcedureSetting> ProcedureSettings { get; set; }
	public List<EnumSetting> EnumSettings {get; set;}
	public JsonType JsonType { get; set; }
	public string ViewPrefix {get; set;}
	public string SequencePrefix {get; set;}
	public string SequenceSuffix {get; set;}

    private Dictionary<EntitySetting, List<FieldMetadata>> FieldsMetadataByEntity;

    private Dictionary<EntitySetting, List<string>> ViewsByEntity;
	public Dictionary<EntitySetting, List<KeyValuePair<string,string>>> ProjectionColumnListsByEntity = new  Dictionary<EntitySetting, List<KeyValuePair<string,string>>>();

    public DataLayerGeneration()
    {
        DataServiceName = "AppDataService";
        RootNamespace = "inercya.Entities";
        ProceduresClassName = "StoredProcedures";
		EntityNameToEntityViewTransform = TextTransform.None;
		ConnectionStringName = "AppConnectionString";
		EntityTypesTableName = "EntityTypes";
		EntityTypeNameColumnName = "EntityTypeName";
		EnumSettings = new List<EnumSetting>();
    }

	private  DbProviderFactory _factory;
	public DbProviderFactory Factory
	{
		get
		{
			if (_factory==null)
			{
				_factory = DbProviderFactories.GetFactory(ProviderName);
			}
			return _factory;
		}
	}


    public DbConnection OpenConnection()
    {
        DbConnection cn = Factory.CreateConnection();
        cn.ConnectionString = this.ConnectionString;
        cn.Open();
        return cn;
    }

	private DbCommandBuilder _commandBuilder;
	public DbCommandBuilder CommandBuilder
	{
		get
		{
			if (_commandBuilder == null)
			{
				_commandBuilder = Factory.CreateCommandBuilder();
			}
			return _commandBuilder;
		}
	}

	private string GetConnectionStringFromSecrets() 
	{
	        
            var secretsFilePath = System.IO.Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "Microsoft", "UserSecrets", UserSecretsId, "secrets.json");
            if (!System.IO.File.Exists(secretsFilePath))
            {
                throw new System.IO.FileNotFoundException("secrets.json file doesn't exist", secretsFilePath);
            }
            var json = System.IO.File.ReadAllText(secretsFilePath);

            var newtonSoftNugetFolder = System.IO.Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.UserProfile),
                ".nuget", "packages", "newtonsoft.json");

            var lastJsonNugetFolder = System.IO.Directory.GetDirectories(newtonSoftNugetFolder).OrderByDescending(x => x).FirstOrDefault();

            var jsonAssemblyPath = System.IO.Path.Combine(lastJsonNugetFolder, "lib", "net45", "Newtonsoft.Json.dll");
            var asm = Assembly.LoadFrom(jsonAssemblyPath);
            var jtokenType = asm.GetType("Newtonsoft.Json.Linq.JToken", true);
            var parseMethod = jtokenType.GetMethod("Parse", BindingFlags.Public | BindingFlags.Static, null, new Type[] { typeof(string) }, null);
            var token = parseMethod.Invoke(null, new object[] { json });

            var indexerProperty = jtokenType.GetProperty("Item");
            return indexerProperty.GetMethod.Invoke(token, new object[] { "ConnectionStrings:" + ConnectionStringName }).ToString();

	}


	public static Type GetTypeFromDbType(DbType dbType)
    {
        return TypeByDbType[dbType];
    }

    private IDictionary<string, IList<ProcedureSetting>> ProceduresByFullEntityName;

    public IList<ProcedureSetting> GetRelatedProcedures(string entityName, string schema)
    {
        string fullEntityName = EntitySetting.GetFullEntityName(entityName, schema, DefaultSchema);
        if (this.ProceduresByFullEntityName == null)
        {
			if (this.ProcedureSettings == null)
			{
				this.ProceduresByFullEntityName = new Dictionary<string, IList<ProcedureSetting>>();
			}
			else
			{
				this.ProceduresByFullEntityName = Extensions.ToListDictionary(this.ProcedureSettings, x => EntitySetting.GetFullEntityName(x.RelatedEntityName, x.RelatedEntitySchema, DefaultSchema)); 
			}
        }
        IList<ProcedureSetting> relatedProcedures = null;
        this.ProceduresByFullEntityName.TryGetValue(fullEntityName, out relatedProcedures);
        return relatedProcedures;
    }

    private Dictionary<string, DbCommand> ProceduresByFullName;

    public DbCommand GetProcedure(ProcedureSetting procedure)
    {

        if (ProceduresByFullName == null) ProceduresByFullName = new Dictionary<string, DbCommand>();
        string fullName = procedure.GetFullProcedureName();
        DbCommand cmd = null;
        if (!ProceduresByFullName.TryGetValue(fullName, out cmd))
        {
            using (var cn = OpenConnection())
            {
                cmd = cn.CreateCommand();
                cmd.CommandText = fullName;
                cmd.CommandType = CommandType.StoredProcedure;
                if (ProviderName == "System.Data.SqlClient")
                {
                    SqlCommandBuilder.DeriveParameters((SqlCommand)cmd);
                }
				else if (ProviderName == "MySql.Data.MySqlClient")
				{
					var commandBuilderType = Type.GetType("MySql.Data.MySqlClient.MySqlCommandBuilder, " + Factory.GetType().Assembly.FullName, true);
					var mi = commandBuilderType.GetMethod("DeriveParameters", BindingFlags.Public | BindingFlags.Static);
					mi.Invoke(null, new object[] {cmd});
				}
				else if (ProviderName == "Oracle.DataAccess.Client")
				{
					var commandBuilderType = Type.GetType("Oracle.DataAccess.Client.OracleCommandBuilder, " + Factory.GetType().Assembly.FullName, true);
					var mi = commandBuilderType.GetMethod("DeriveParameters", BindingFlags.Public | BindingFlags.Static);
					mi.Invoke(null, new object[] {cmd});				
				}
				else if (ProviderName == "Oracle.ManagedDataAccess.Client")
				{
					var commandBuilderType = Type.GetType("Oracle.ManagedDataAccess.Client.OracleCommandBuilder, " + Factory.GetType().Assembly.FullName, true);
					var mi = commandBuilderType.GetMethod("DeriveParameters", BindingFlags.Public | BindingFlags.Static);
					mi.Invoke(null, new object[] {cmd});				
				}
				else if (ProviderName == "Devart.Data.Oracle")
				{
					var commandBuilderType = Type.GetType("Devart.Data.Oracle.OracleCommandBuilder, " + Factory.GetType().Assembly.FullName, true);
					var mi = commandBuilderType.GetMethod("DeriveParameters", BindingFlags.Public | BindingFlags.Static);
					mi.Invoke(null, new object[] {cmd});					
				}
				else if (ProviderName == "Npgsql")
				{
					var commandBuilderType = Type.GetType("Npgsql.NpgsqlCommandBuilder, " + Factory.GetType().Assembly.FullName, true);
					var mi = commandBuilderType.GetMethod("DeriveParameters", BindingFlags.Public | BindingFlags.Static);
					mi.Invoke(null, new object[] {cmd});				
				}
				else if (ProviderName == "FirebirdSql.Data.FirebirdClient")
				{
					var commandBuilderType = Type.GetType("FirebirdSql.Data.FirebirdClient.FbCommandBuilder, " + Factory.GetType().Assembly.FullName, true);
					var mi = commandBuilderType.GetMethod("DeriveParameters", BindingFlags.Public | BindingFlags.Static);
					mi.Invoke(null, new object[] {cmd});
					var outputParameters = cmd.Parameters.Cast<DbParameter>().Where(x => x.Direction == ParameterDirection.Output).ToList();
					foreach(var p in outputParameters)
					{
						cmd.Parameters.Remove(p);
					}
				}
                else
                {
                    throw new NotSupportedException("Stored procedures aren't supported for " + ProviderName);
                }
                ProceduresByFullName[fullName] = cmd;
            }
        }

        foreach (var p in cmd.Parameters.Cast<IDbDataParameter>())
        {
            string sourceColumn = p.ParameterName;
            if (!string.IsNullOrEmpty(sourceColumn) && (sourceColumn[0] == '@' || sourceColumn[0] == ':'))
            {
                p.SourceColumn = sourceColumn.Substring(1);
            }
        }

        return cmd;
    }

    private void GenerateEntityTypes()
    {
        using (var db = this.OpenConnection())
        using (var cmd = db.CreateCommand())
        using (var adapter = Factory.CreateDataAdapter())
        {
            cmd.CommandText = "SELECT * FROM " + EntityTypesTableName;
            var dt = new DataTable(EntityTypesTableName);
            adapter.MissingSchemaAction = MissingSchemaAction.AddWithKey;
            adapter.SelectCommand = cmd;
            adapter.Fill(dt);
            var idColumnName = dt.PrimaryKey[0].ColumnName;
            object lastIdObj = dt.Compute($"max([{idColumnName}])", string.Empty);
            int lastId = Convert.IsDBNull(lastIdObj) ? 0 : Convert.ToInt32(lastIdObj);
            var existingEntityTypes = new SortedSet<string>(dt.Rows.Cast<DataRow>().Select(x => (string)x[EntityTypeNameColumnName]));
            bool areThereNewEntities = false;
            foreach (var entitySetting in EntitySettings.Where( x => !existingEntityTypes.Contains(EntitySetting.GetFullEntityName(x.EntityName, x.Schema, DefaultSchema))))
            {
                dt.Rows.Add(++lastId, EntitySetting.GetFullEntityName(entitySetting.EntityName, entitySetting.Schema, DefaultSchema));
                areThereNewEntities = true;
            }
            if (areThereNewEntities)
            {
                using (var tx = db.BeginTransaction())
                {
                    cmd.Transaction = tx;
                    var builder = Factory.CreateCommandBuilder();
                    builder.DataAdapter = adapter;
                    adapter.Update(dt);
                    tx.Commit();
                }
            }
        }
    }

	private Dictionary<string, EnumSetting> EnumSettingsByIdField;


    public void Initialize()
    {
		SetEnumSettigsByIdField();
		LoadSequences();
        SetViewsByEntity();
        SetFieldsMetadataByEntity();
		
		
        //This would work only with SQL Server and if the EntityTypes Table exists
        if (GenerateEntityTypeId) GenerateEntityTypes();
    }

	private void SetEnumSettigsByIdField() 
	{
		EnumSettingsByIdField = this.EnumSettings.ToDictionary(x => x.GetFullIdField());
	}

	private static Dictionary<Type, DbType> DataTypeToDbType = new Dictionary<Type, DbType>() {
		{ typeof(byte[]), DbType.Binary },
		{ typeof(bool), DbType.Boolean },
		{ typeof(byte), DbType.Byte },
		{ typeof(DateTime), DbType.DateTime },
		{ typeof(DateTimeOffset), DbType.DateTimeOffset },
		{ typeof(Decimal), DbType.Decimal},
		{ typeof(double), DbType.Double },
		{ typeof(Guid), DbType.Guid },
		{ typeof(short), DbType.Int16 },
		{ typeof(int), DbType.Int32},
		{ typeof(long), DbType.Int64 },
		{ typeof(sbyte), DbType.SByte },
		{ typeof(Single), DbType.Single }, 
		{ typeof(string), DbType.String }, 
		{ typeof(ushort), DbType.UInt16 },
		{ typeof(uint), DbType.UInt32 },
		{ typeof(ulong), DbType.UInt64 }
	};

	public DbType ToDbType(Type dataType)
	{
		DbType dbType;
		if (DataTypeToDbType.TryGetValue(dataType, out dbType)) return dbType;
		return DbType.Object;
	}

    public DbType ToDbType(int providerType)
    {
        switch (ProviderName)
        {
            case "System.Data.SqlClient":
                SqlParameter sqlParam = new SqlParameter();
                sqlParam.SqlDbType = (SqlDbType)providerType;
                return sqlParam.DbType;
            case "System.Data.SQLite":
                return (DbType)providerType;
			case "MySql.Data.MySqlClient":
				dynamic mySqlParam = Factory.CreateParameter();
				Type mySqlDbTypeType = mySqlParam.MySqlDbType.GetType();
				Extensions.SetPropertyValue(mySqlParam, "MySqlDbType", Enum.ToObject(mySqlDbTypeType, providerType));
				return (DbType) mySqlParam.DbType; 
			case "Oracle.DataAccess.Client":
			case "Oracle.ManagedDataAccess.Client":
				dynamic oracleParam = Factory.CreateParameter();
				Type oracleDbTypeType = oracleParam.OracleDbType.GetType();
				Extensions.SetPropertyValue(oracleParam, "OracleDbType", Enum.ToObject(oracleDbTypeType, providerType));
				return (DbType) oracleParam.DbType; 
			case "Devart.Data.Oracle":
				dynamic devartParam = Factory.CreateParameter();
				Type devartDbTypeType = devartParam.OracleDbType.GetType();
				Extensions.SetPropertyValue(devartParam, "OracleDbType", Enum.ToObject(devartDbTypeType, providerType));
				return (DbType) devartParam.DbType; 
			case "FirebirdSql.Data.FirebirdClient":
				dynamic firebirdParam = Factory.CreateParameter();
				Type firebirdDbTypeType = firebirdParam.FbDbType.GetType();
				Extensions.SetPropertyValue(firebirdParam, "FbDbType", Enum.ToObject(firebirdDbTypeType, providerType));
				return (DbType) firebirdParam.DbType;
            default:
                throw new NotSupportedException("provider " + ProviderName + " is not supported");
        }
    }

    private Dictionary<string, EntitySetting> EntitiesByFullName;

    public EntitySetting GetEntitySetting(string entityName, string schema)
    {
        string fullEntityName = EntitySetting.GetFullEntityName(entityName, schema, DefaultSchema);
        if (EntitiesByFullName == null)
        {
            EntitiesByFullName = this.EntitySettings.ToDictionary(x => x.FullEntityName);
        }
        return EntitiesByFullName[fullEntityName];
    }


    private void SetFieldsMetadataByEntity()
    {
        var langLength = "Lang1".Length;
        using (var cn = this.OpenConnection())
        {
            this.FieldsMetadataByEntity = new Dictionary<EntitySetting, List<FieldMetadata>>();
            foreach (var entity in this.EntitySettings)
            {
                var fieldsMetadata = new List<FieldMetadata>();
                var schema = GetSchemaUnion(entity, cn);

                var readOnlyFields = entity.GetReadOnlyFields();
				var roundDateFields = entity.GetRoundDateFields();
                HashSet<string> localizedFields = new HashSet<string>();
                foreach (var row in schema.Rows.Cast<DataRow>().Where( x => !schema.Columns.Contains("IsHidden") || x["IsHidden"].GetType() != typeof(bool) || !(bool) x["IsHidden"]))
                {                     
                    var fieldMetadata = new FieldMetadata
                    {
						ColumnName = (string)row["ColumnName"],
                        BaseColumnName =  Convert.IsDBNull(row["BaseColumnName"]) ? string.Empty : (string) row["BaseColumnName"],
                        BaseSchemaName = Convert.IsDBNull(row["BaseSchemaName"]) ? string.Empty : (string) row["BaseSchemaName"],
                        BaseTableName = Convert.IsDBNull(row["BaseTableName"]) ? string.Empty : (string) row["BaseTableName"],
                        DbType = (DbType) row["DbType"],
                        IsAutoIncrement = Convert.IsDBNull(row["IsAutoincrement"]) ? false : (bool) row["IsAutoincrement"],
                        IsKey =  (bool) row["IsKey"],
                        IsNullable = ((Type)row["DataType"]).IsValueType && (bool) row["AllowDBNull"],
                        IsReadOnly = (bool) row["IsReadOnly"] || readOnlyFields.Contains((string) row["ColumnName"]),
						IsRoundDate = roundDateFields.Contains((string)row["ColumnName"]),
                        Precision = Convert.IsDBNull(row["NumericPrecision"]) ? (byte) 255 : Convert.ToByte(row["NumericPrecision"]),
                        PropertyName = Extensions.ToPascalNamingConvention(((string)row["ColumnName"])),
                        PropertyType = (Type)row["DataType"],
                        Scale = (Convert.IsDBNull(row["NumericScale"]) || Convert.ToInt32(row["NumericScale"]) < 0) ? (byte) 255 : Convert.ToByte(row["NumericScale"]),
                        ColumnSize = (int) row["ColumnSize"],
						ProviderType = ShouldUseProviderType(row["ProviderType"]) ? (int?) Convert.ToInt32(row["ProviderType"]) : (int?) null
                    };

					fieldMetadata.PropertyTypeName = GetTypeName(fieldMetadata.PropertyType) + (fieldMetadata.IsNullable && !typeof(INullable).IsAssignableFrom(fieldMetadata.PropertyType) ? "?" : string.Empty);
					if (this.JsonType != JsonType.None && fieldMetadata.PropertyType == typeof(string) && fieldMetadata.PropertyName.EndsWith("Json"))
					{
						fieldMetadata.PropertyTypeName = "Newtonsoft.Json.Linq." + this.JsonType.ToString();
						fieldMetadata.PropertyName = fieldMetadata.PropertyName.Substring(0, fieldMetadata.PropertyName.Length - 4);
					}
					EnumSetting enumSetting;
					var fullPropertyName = EntitySetting.GetFullEntityName(fieldMetadata.PropertyName, entity.Schema, DefaultSchema);
					if (EnumSettingsByIdField.TryGetValue(fullPropertyName, out enumSetting))
					{
						fieldMetadata.PropertyTypeName = fieldMetadata.IsNullable ? enumSetting.TypeName + "?" : enumSetting.TypeName;
						fieldMetadata.PropertyName = enumSetting.TypeName;
					}
					string mappedPropertyName = null;

					if (entity.RemoveFieldPrefixes != null) {
						var removeFieldPrefixes = entity.RemoveFieldPrefixes.Split(new char[] {','}, StringSplitOptions.RemoveEmptyEntries);
						foreach (var removeFieldPrefix in removeFieldPrefixes)
						{
							var fieldPrefix = removeFieldPrefix.Trim();
							if (!string.IsNullOrEmpty(fieldPrefix) && fieldMetadata.PropertyName.StartsWith(fieldPrefix) && fieldMetadata.PropertyName.Length > fieldPrefix.Length && char.IsUpper(fieldMetadata.PropertyName[fieldPrefix.Length]))
							{
								fieldMetadata.PropertyName = fieldMetadata.PropertyName.Substring(fieldPrefix.Length);
							}
						}
					}
					if (entity.ColumnToPropertyMap != null && entity.ColumnToPropertyMap.TryGetValue((string)row["ColumnName"], out mappedPropertyName))
					{
						fieldMetadata.PropertyName = mappedPropertyName;
					}
					if (fieldMetadata.BaseSchemaName == "sqlite_default_schema" && ProviderName == "System.Data.SQLite")
					{
						fieldMetadata.BaseSchemaName = null;
					}
					if (string.IsNullOrEmpty(entity.BaseTableName) 
						|| !string.Equals(fieldMetadata.BaseTableName, entity.BaseTableName, StringComparison.InvariantCultureIgnoreCase)
						|| ! (string.Equals(fieldMetadata.BaseSchemaName ?? string.Empty, entity.Schema ?? string.Empty, StringComparison.InvariantCultureIgnoreCase) || entity.Schema == null && string.Equals(fieldMetadata.BaseSchemaName ?? string.Empty, DefaultSchema ?? string.Empty, StringComparison.InvariantCultureIgnoreCase))
						)
					{
						fieldMetadata.BaseSchemaName = null;
						fieldMetadata.BaseColumnName = null;
						fieldMetadata.BaseTableName = null;
					}

					if (!string.IsNullOrEmpty(entity.SynonymName) && fieldMetadata.BaseTableName != null)
					{
						fieldMetadata.BaseTableName = entity.SynonymName;
						fieldMetadata.BaseSchemaName = string.IsNullOrEmpty(entity.SynonymSchema) ? DefaultSchema : entity.SynonymSchema;
					}


                    fieldsMetadata.Add(fieldMetadata);
                    if (fieldMetadata.PropertyName.Length > langLength)
                    {
                        var localizedPropertyName = fieldMetadata.PropertyName.Substring(0, fieldMetadata.PropertyName.Length - langLength);
                        var langLiteral = fieldMetadata.PropertyName.Substring(localizedPropertyName.Length, langLength - 1);
                        if (langLiteral == "Lang")
                        {
                            if (!localizedFields.Contains(localizedPropertyName))
                            {
                                localizedFields.Add(localizedPropertyName);
                            }
                        }
                    }
                }

                foreach (string localizedField in localizedFields)
                {
                    var fieldMetadata = new FieldMetadata
                    {
                        PropertyName = (string)localizedField,
                        PropertyType = typeof(string),
                        IsLocalizedField = true

                    };
                    fieldsMetadata.Add(fieldMetadata);
                }

                this.FieldsMetadataByEntity.Add(entity, fieldsMetadata);

				if (! string.IsNullOrEmpty(entity.SynonymName)) {
					entity.BaseTableName = entity.SynonymName;
					entity.Schema = entity.SynonymSchema;
				}
				var primaryKey = GetPrimaryKey(entity);
				if (primaryKey.Count == 1)
				{
					var pkfieldMetadata = primaryKey[0];
					string schemaName = GetSchemaName(entity);
					string fullSequenceName = null;
					string  sequenceName = null;
					if (!string.IsNullOrEmpty(entity.SequenceName))
					{
						sequenceName = entity.SequenceName;
					}
					else 
					{
						if (ProviderName == "Oracle.DataAccess.Client" || ProviderName == "Oracle.ManagedDataAccess.Client" || ProviderName == "Devart.Data.Oracle")
						{
							sequenceName = pkfieldMetadata.BaseColumnName;
						}
						else if (ProviderName == "FirebirdSql.Data.FirebirdClient")
						{
							sequenceName = entity.BaseTableName;
						}
						else
						{
							sequenceName = pkfieldMetadata.BaseTableName + "_" + pkfieldMetadata.BaseColumnName;
						}
						if (!string.IsNullOrEmpty(SequencePrefix)) {
							sequenceName = SequencePrefix + sequenceName;
						}
						if (!string.IsNullOrEmpty(SequenceSuffix)) {
							sequenceName = sequenceName + SequenceSuffix;
						}
					}
					fullSequenceName = string.IsNullOrEmpty(schemaName) ? sequenceName : schemaName + "." + sequenceName;
					Sequence seq = null;
					if (Sequences.TryGetValue(fullSequenceName, out seq))
					{
						pkfieldMetadata.SequenceName = seq.SequenceName;
					}
					else if (!string.IsNullOrEmpty(entity.SequenceName))
					{
						throw new ArgumentException("The sequence " + fullSequenceName + " doesn't exist in the database");
					}
				}
            }
        }
    }

    private DataTable GetSchema(string tableOrView, DbConnection cn)
    {
        using (DbCommand selectCommand = cn.CreateCommand())
        {
            selectCommand.CommandText = "SELECT * FROM " + tableOrView;
			if (ProviderName == "System.Data.SQLite")
			{
				selectCommand.CommandText +=  " LIMIT 1";
			}
			else
			{
				selectCommand.CommandText += " WHERE 1=0";
			}
			
            using (DbDataReader reader = selectCommand.ExecuteReader(CommandBehavior.KeyInfo))
            {
                var schema = reader.GetSchemaTable();
				bool isProviderTypeInt = schema.Columns["ProviderType"].DataType == typeof(int) || schema.Columns["ProviderType"].DataType.IsEnum;;
				schema.Columns.Add("DbType", typeof(DbType));
				if (schema.Columns.Contains("IsHidden")) 
				{
					var hidden = schema.Rows.Cast<DataRow>().Where(x => x["IsHidden"].GetType() == typeof(bool) && (bool) x["IsHidden"]).ToList();
					foreach (var row in hidden)
					{
						schema.Rows.Remove(row);
					}
				}
                schema.Constraints.Add("PK_Schema", schema.Columns["ColumnName"], true);
				if (!schema.Columns.Contains("IsAutoIncrement")) {
					schema.Columns.Add("IsAutoIncrement", typeof(bool));
				}
                schema.Columns["IsAutoIncrement"].ReadOnly = false;
				MethodInfo getFieldDbTypeMehtodInfo = reader.GetType().GetMethod("GetFieldDbType");
				foreach(DataRow row in schema.Rows)
				{
					if (getFieldDbTypeMehtodInfo != null)
					{
						row["DbType"] = getFieldDbTypeMehtodInfo.Invoke(reader, new object[] { (int)row["ColumnOrdinal"] - 1} );
					}
					else if (isProviderTypeInt)
					{
						row["DbType"] = ToDbType( Convert.ToInt32( row["ProviderType"]));
					}
					else {
						row["DbType"] =  ToDbType( (Type) row["DataType"]);
					}
				}
				schema.AcceptChanges();
                return schema;
            }
        }
    }

    private string GetSchemaName(EntitySetting entity)
    {
        if (string.IsNullOrEmpty(entity.Schema))
        {
            return DefaultSchema;
        }
        else
        {
            return entity.Schema;
        }
    }

	private void AddProjectionColumnList(EntitySetting entity, string projectionName, DataTable schema)
	{
		List<KeyValuePair<string, string>> projectionColumnLists;
		if (!ProjectionColumnListsByEntity.TryGetValue(entity, out projectionColumnLists)) 
		{
			projectionColumnLists = new List<KeyValuePair<string, string>>();
			ProjectionColumnListsByEntity.Add(entity, projectionColumnLists);
		}
		var escapedQuotePrefix = CommandBuilder.QuotePrefix.Replace("\"", "\\\"");
		var escapedQuoteSuffix = CommandBuilder.QuoteSuffix.Replace("\"", "\\\"");
		var columns = schema.Rows.Cast<DataRow>()
			.Where(x => !schema.Columns.Contains("IsHidden") || x["IsHidden"].GetType() != typeof(bool) || !(bool) x["IsHidden"])
			.Select(x => escapedQuotePrefix + (string) x["ColumnName"] + escapedQuoteSuffix);
		var columnList = string.Join(", ", columns);
		projectionColumnLists.Add(new KeyValuePair<string, string>(projectionName, columnList));
	}

	private string DeriveProjectionName(string entityName, string viewName)
	{
		var tokens = viewName.Split('.');
		viewName = tokens[tokens.Length - 1];
		var transformedEntityName = Extensions.Transform(entityName, EntityNameToEntityViewTransform);
		var prefixedTransformedEntityName = string.IsNullOrEmpty(ViewPrefix) ? transformedEntityName + "_" : ViewPrefix.ToLower() +  transformedEntityName + "_";
		return Extensions.ToPascalNamingConvention(viewName.Substring(prefixedTransformedEntityName.Length));
	}


    private DataTable GetSchemaUnion(EntitySetting entitySetting, DbConnection cn)
    {
        DataTable schemaUnion = null;
           
        DataTable baseTableSchema = null;
        if (!string.IsNullOrEmpty(entitySetting.BaseTableName))
        {
            baseTableSchema = GetSchema(entitySetting.GetFullObjectName(DefaultSchema, CommandBuilder.QuotePrefix, CommandBuilder.QuoteSuffix), cn);
			AddProjectionColumnList(entitySetting, "BaseTable", baseTableSchema);
            if ((entitySetting.FieldGeneration & FieldGeneration.ForBaseTable) == FieldGeneration.ForBaseTable)
            {
                schemaUnion = baseTableSchema.Copy();
            }
        }

        foreach (string viewName in this.ViewsByEntity[entitySetting])
        {
          
            DataTable schema = GetSchema(viewName, cn);
            AddProjectionColumnList(entitySetting, DeriveProjectionName(entitySetting.EntityName, viewName), schema);    
            if (schemaUnion == null)
            {
                schemaUnion = schema.Clone();
            }
            foreach (DataRow row in schema.Rows)
            {
				string columnName = (string)row["ColumnName"];
                if (schemaUnion.Rows.Find(columnName) == null)
                {
					DataRow rowToImport = row;
                    if (baseTableSchema != null)
                    {
						DataRow baseTableRow = baseTableSchema.Rows.Find(columnName);
						if (baseTableRow != null) rowToImport = baseTableRow;
                    }
                    schemaUnion.ImportRow(rowToImport);
                }
            }
        }
		if (schemaUnion == null)
		{
			throw new InvalidOperationException("Cannot obtain metadata for entity " + entitySetting.EntityName + " from database");
		}
		return schemaUnion;
    }

    private void SetViewsByEntity()
    {
        using (var cn = this.OpenConnection())
        {
            this.ViewsByEntity = new Dictionary<EntitySetting, List<string>>();
            DataTable allViews = cn.GetSchema("Views");
			string nameColumn = "TABLE_NAME";
			string schemaColumn = "TABLE_SCHEMA";
			if (ProviderName == "Oracle.DataAccess.Client" || ProviderName == "Oracle.ManagedDataAccess.Client")
			{
				nameColumn = "VIEW_NAME";
				schemaColumn = "OWNER";
			}
			else if (ProviderName == "Devart.Data.Oracle")
			{
				nameColumn = "Name";
				schemaColumn = "Schema";
			}
			else if (ProviderName == "FirebirdSql.Data.FirebirdClient")
			{
				nameColumn = "VIEW_NAME";
				schemaColumn = "VIEW_SCHEMA";
			}
            foreach (var entity in this.EntitySettings.OrderByDescending(x => x.EntityName.Length))
            {
                var views = new List<string>();
				var rowsToDelete = new List<DataRow>();
                foreach (DataRow row in allViews.Rows)
                {
                    string viewName = (string)row[nameColumn];
                    string viewSchema = Convert.IsDBNull(row[schemaColumn]) ? null : (string)row[schemaColumn];
                    string fullViewName = viewSchema == null ? viewName : viewSchema + "." + viewName;  
					var transformedEntityName = Extensions.Transform(entity.EntityName, EntityNameToEntityViewTransform).ToLower();
					var prefixedTransformedEntityName = string.IsNullOrEmpty(ViewPrefix) ? transformedEntityName + "_" : ViewPrefix.ToLower() +  transformedEntityName + "_";
                    if (string.Equals(GetSchemaName(entity) ?? string.Empty, viewSchema ?? string.Empty, StringComparison.InvariantCultureIgnoreCase) && viewName.ToLower().StartsWith(prefixedTransformedEntityName))
                    {
                        views.Add(fullViewName);
						rowsToDelete.Add(row);
                    }                      
                }

				foreach(var row in rowsToDelete) 
				{
					row.Delete();
				}
				allViews.AcceptChanges();

                this.ViewsByEntity.Add(entity, views);
            }
        }
    }

    public List<FieldMetadata> GetFieldsMetadata(EntitySetting entity)
    {
        return this.FieldsMetadataByEntity[entity];

    }

    public List<FieldMetadata> GetPrimaryKey(EntitySetting entity)
    {

        var fullObjectName = entity.GetFullObjectName(DefaultSchema, CommandBuilder.QuotePrefix , CommandBuilder.QuoteSuffix);
        return GetFieldsMetadata(entity).Where(x => x.IsKey 
            && ! string.IsNullOrEmpty(entity.BaseTableName)
            && string.Equals(fullObjectName, x.FullTableName(CommandBuilder.QuotePrefix , CommandBuilder.QuoteSuffix), StringComparison.InvariantCultureIgnoreCase) ).ToList(); 

    }

    #region IDisposable Members

    public void Dispose()
    {
        if (this.ProceduresByFullName != null)
        {
            foreach (var proc in this.ProceduresByFullName.Values)
            {
                proc.Dispose();
            }
            this.ProceduresByFullName = null;
        }
    }

    #endregion

    public static string GetProcedureParametersDefinition(DbCommand cmd)
    {
        var parameters = cmd.Parameters.Cast<IDbDataParameter>()
          .Where(p => p.Direction != ParameterDirection.ReturnValue)
          .Select(p =>
          {
			  string paramDef = null;
			  string sourceColumn = p.ParameterName;
			  if ( sourceColumn[0] == '@' || sourceColumn[0] == ':')
			  {
					sourceColumn = sourceColumn.Substring(1);
			  }
			  Type paramType = DataLayerGeneration.GetTypeFromDbType(p.DbType);
			  string paramTypeName = paramType.IsValueType ? paramType.Name + "?" : paramType.Name;
			  string argumentName = Extensions.EscapeKeyword(Extensions.ToParameterName(Extensions.ToPascalNamingConvention(sourceColumn)));
			  paramDef = paramTypeName + " " + argumentName;

			  if (p.Direction == ParameterDirection.Output)
			  {
				paramDef = "out " + paramDef;
			  }
			  else if (p.Direction == ParameterDirection.InputOutput)
			  {
				paramDef = "ref " + paramDef;
			  }
			  return paramDef;
          }).ToArray();
          return string.Join(", ", parameters);
    }

	private void LoadSequences()
	{
		string commandText = null;
		if (ProviderName == "Oracle.DataAccess.Client" || ProviderName == "Oracle.ManagedDataAccess.Client" || ProviderName == "Devart.Data.Oracle")
		{
			commandText = "SELECT SEQUENCE_OWNER AS SEQUENCE_SCHEMA, SEQUENCE_NAME FROM ALL_SEQUENCES";
		}
		else if (ProviderName == "FirebirdSql.Data.FirebirdClient")
		{
			commandText = "SELECT '' AS SEQUENCE_SCHEMA, RDB$GENERATOR_NAME AS SEQUENCE_NAME FROM RDB$GENERATORS";
		}
		else if (ProviderName == "System.Data.SqlClient")
		{
			commandText = @"
SELECT 
	sh.name AS SEQUENCE_SCHEMA, seq.name AS  SEQUENCE_NAME
FROM 
	sys.sequences seq 
	INNER JOIN sys.schemas sh on seq.schema_id = sh.schema_id";
		}
		if (commandText != null)
		{
			using (var cn = OpenConnection())
			{
				var areSequencesSupported = true;
				int version = 0;
				if (ProviderName == "System.Data.SqlClient") {
					version = int.Parse(cn.ServerVersion.Split('.')[0]);
					if (version < 11) areSequencesSupported = false;
				}

				if (areSequencesSupported)
				{
					using (var cmd = cn.CreateCommand())
					{
						cmd.CommandText = commandText;
						Sequences = new Dictionary<string, Sequence>(StringComparer.InvariantCultureIgnoreCase);
						using (var reader = cmd.ExecuteReader()) 
						{
							while(reader.Read())
							{
								var sequence = new Sequence {
									SequenceSchema = reader.GetString(0).Trim(),
									SequenceName = reader.GetString(1).Trim()
								};
								Sequences.Add(sequence.FullSequenceName, sequence);
							}
						}
					}
				}
				else
				{
					Sequences = new Dictionary<string, Sequence>();
				}
			}
		}
		else 
		{
			Sequences = new Dictionary<string, Sequence>();
		}

	}
  
  private Dictionary<string, Sequence> Sequences;

    public static readonly Dictionary<DbType, Type> TypeByDbType = new Dictionary<DbType, Type>
    {
        { DbType.AnsiString, typeof(string) },
        { DbType.AnsiStringFixedLength, typeof(string) },
        { DbType.Binary, typeof(byte[]) },
        { DbType.Boolean, typeof(bool) },
        { DbType.Byte, typeof(byte) },
        { DbType.Currency, typeof(decimal) },
        { DbType.Date, typeof(DateTime) },
        { DbType.DateTime, typeof(DateTime) },
        { DbType.DateTime2, typeof(DateTime) },
        { DbType.DateTimeOffset, typeof(DateTimeOffset) },
        { DbType.Decimal, typeof(decimal) },
        { DbType.Double, typeof(double) },
        { DbType.Guid, typeof(Guid) },
        { DbType.Int16, typeof(short) },
        { DbType.Int32, typeof(int) },
        { DbType.Int64, typeof(long) },
        { DbType.Object, typeof(object) },
        { DbType.SByte, typeof(SByte) },
        { DbType.Single, typeof(float) },
        { DbType.String, typeof(string) },
        { DbType.StringFixedLength, typeof(string) },
        { DbType.Time, typeof(TimeSpan) },
        { DbType.UInt16, typeof(ushort) },
        { DbType.UInt32, typeof(uint) },
        { DbType.UInt64, typeof(ulong) },
        { DbType.VarNumeric, typeof(decimal) },
        { DbType.Xml, typeof(string) }
    };

	public string GetTypeName(Type t)
    {
        return GetCSharpRepresentation(t, new Queue<Type>(t.GetGenericArguments()));
    }
    
	public string GetCSharpRepresentation(Type t, Queue<Type> availableArguments)
    {
        string value = t.Name;
        if (t.IsGenericParameter)
        {
            return value;
        }
        if (t.DeclaringType != null)
        {
            // This is a nested type, build the parent type first
            value = GetCSharpRepresentation(t.DeclaringType, availableArguments) + "+" + value;
        }
        if (t.IsGenericType)
        {
            value = value.Split('`')[0];

            // Build the type arguments (if any)
            string argString = "";
            var thisTypeArgs = t.GetGenericArguments();
            for (int i = 0; i < thisTypeArgs.Length && availableArguments.Count > 0; i++)
            {
                if (i != 0) argString += ", ";

                argString += GetTypeName(availableArguments.Dequeue());
            }

            // If there are type arguments, add them with < >
            if (argString.Length > 0)
            {
                value += "<" + argString + ">";
            }
        }

        return value;
    }

		private Type _providerDbTypeType;
	private Type ProviderDbTypeType  {
		get {
			if (_providerDbTypeType == null) {
				switch (ProviderName)
				{
					case "System.Data.SqlClient":
						_providerDbTypeType = typeof(SqlDbType); break;
					case "System.Data.SQLite":
						_providerDbTypeType = typeof(DbType); break;
					case "MySql.Data.MySqlClient":
						dynamic mySqlParam = Factory.CreateParameter();
						_providerDbTypeType = mySqlParam.MySqlDbType.GetType();
						break;
					case "Oracle.DataAccess.Client":
					case "Oracle.ManagedDataAccess.Client":
					case "Devart.Data.Oracle":
						dynamic oracleParam = Factory.CreateParameter();
						_providerDbTypeType = oracleParam.OracleDbType.GetType();
						break;
					default:
						throw new NotSupportedException("provider " + ProviderName + " is not supported");
				}
			}
			return _providerDbTypeType;
		}
	} 


	bool ShouldUseProviderType(object providerType) {
		if (ProviderName == "Oracle.DataAccess.Client" || ProviderName == "Oracle.ManagedDataAccess.Client" || ProviderName == "Devart.Data.Oracle")
		{
			var providerDbTypeName = Enum.ToObject(ProviderDbTypeType, Convert.ToInt32(providerType)).ToString();
			return providerDbTypeName == "NChar" || providerDbTypeName == "NVarchar2" || providerDbTypeName == "NClob" 
				|| providerDbTypeName == "NVarChar" || providerDbTypeName == "Raw" || providerDbTypeName == "Long" || providerDbTypeName == "LongRaw";	
		}
		return false;
	}
}
#>﻿<#+ 
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
void DataServiceGeneration_Render(DataLayerGeneration generation)
{			
#>

namespace <#= generation.RootNamespace #>
{
	public partial class <#= generation.DataServiceName #> : DataService
	{
		partial void OnCreated();

		private void Init()
		{
			EntityNameToEntityViewTransform = TextTransform.<#= generation.EntityNameToEntityViewTransform #>;
<#+	if (! string.IsNullOrEmpty(generation.DefaultSchema)) { #>
			EntityLiteProvider.DefaultSchema = "<#= generation.DefaultSchema #>";
<#+	} #>
<#+	if (generation.AuditDateTimeKind != DateTimeKind.Unspecified) { #>
			AuditDateTimeKind = DateTimeKind.<#= generation.AuditDateTimeKind.ToString() #>;
<#+	} #>
<#+ if (!string.IsNullOrEmpty(generation.ViewPrefix)) { #>
			ViewPrefix = "<#= generation.ViewPrefix #>";
<#+ } #>
<#+ if (!string.IsNullOrEmpty(generation.SequencePrefix)) { #>
			SequencePrefix = "<#= generation.SequencePrefix #>";
<#+ } #>
<#+ if (!string.IsNullOrEmpty(generation.SequenceSuffix)) { #>
			SequenceSuffix = "<#= generation.SequenceSuffix #>";
<#+ } #>
			OnCreated();
		}

        public <#= generation.DataServiceName #>() : base("<#= generation.ConnectionStringName #>")
        {
			Init();
        }

        public <#= generation.DataServiceName #>(string connectionStringName) : base(connectionStringName)
        {
			Init();
        }

        public <#= generation.DataServiceName #>(string connectionString, string providerName) : base(connectionString, providerName)
        {
			Init();
        }
<#+
	foreach (var entity in generation.EntitySettings)
    {
#>

		private <#= entity.GetNamespaceName(generation.RootNamespace) + "." + entity.EntityName #>Repository _<#= entity.GetRepositoryPropertyName() #>;
		public <#= entity.GetNamespaceName(generation.RootNamespace) + "." + entity.EntityName #>Repository <#= entity.GetRepositoryPropertyName() #>
		{
			get 
			{
				if ( _<#= entity.GetRepositoryPropertyName() #> == null)
				{
					_<#= entity.GetRepositoryPropertyName() #> = new <#= entity.GetNamespaceName(generation.RootNamespace) + "." + entity.EntityName #>Repository(this);
				}
				return _<#= entity.GetRepositoryPropertyName() #>;
			}
		}
<#+
    }
#>
	}
}
<#+ 
}
#>﻿<#+
/**
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
void EntityGeneration_Render(DataLayerGeneration generation)
{			
#>
using System;
using System.Linq;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
<#+
if (generation.ProviderName == "System.Data.SqlClient")
{
#>
// using Microsoft.SqlServer.Types;
<#+
}
#>
<#+
if (generation.GenerateDataContractAttributes)
{
#>
using System.Runtime.Serialization;
<#+
}
#>

using System.ComponentModel;
using inercya.EntityLite;	
using inercya.EntityLite.Extensions;	
<#+
	var nsgs = from entity in generation.EntitySettings
			group entity by entity.GetNamespaceName(generation.RootNamespace) into g
			select g;
	foreach (var g in nsgs)
    {
		string namespaceName = g.Key;
#>

namespace <#= namespaceName #>
{
<#+
		foreach (var entity in g)
        {
			RenderEntityClass(generation, entity);
			RenderEntityRepositoryClass(generation, entity);
			RenderEntityFieldsClass(generation, entity);
			RenderProjectionClass(generation, entity);
		}
#>
}
<#+
    }
}	
#>


<#+ /** ************************************************************************************************************************ **/
public void RenderEntityClass(DataLayerGeneration generation, EntitySetting entity)
{
#>
<#+
if (generation.GenerateDataContractAttributes)
{
#>
	[Serializable]
	[DataContract]
<#+
}
#>
<#+
if (generation.GenerateMessagePackAttributes)
{
#>
	[MessagePack.MessagePackObject()]
<#+
}
#>
<#+ if (entity.GenerateTypeScript.HasValue ? entity.GenerateTypeScript.Value : generation.GenerateTypeScript) { #>
    [TypeScript] 
<#+ }#>
	[SqlEntity(<#= entity.GetSqlEntityParameters(generation.DefaultSchema) #>)]
<#+ if (!string.IsNullOrEmpty(entity.ParentPropertyName)) 
	{ 
#>
	[ParentPropertyName("<#= entity.ParentPropertyName #>")]
<#+ 
	} 
#>
	public partial class <#= Extensions.EscapeKeyword(entity.EntityName) #><#= generation.ImplementINotifyPropertyChanged ? " : INotifyPropertyChanged" : string.Empty #>
	{
<#+         if (generation.ImplementINotifyPropertyChanged) { #>
        public event PropertyChangedEventHandler PropertyChanged;

        private void NotifyPropertyChange(string propertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            {
                handler(this, new PropertyChangedEventArgs(propertyName));
            }
        }				
		
<#+         } 
			int fieldIndex = -1;
			foreach (var field in generation.GetFieldsMetadata(entity))
            {
				fieldIndex++;
				string propertyName = Extensions.EscapeKeyword(field.PropertyName);
				string fieldName = "_" + Extensions.ToParameterName(propertyName);
				if (field.IsLocalizedField)
                {
#>
		[LocalizedField]
<#+
if (generation.GenerateDataContractAttributes)
{
#>
		[DataMember]
<#+
}
#>
<#+
if (generation.GenerateMessagePackAttributes)
{
#>
		[MessagePack.Key(<#= fieldIndex #>)]
<#+
}
#>
<#+					if (field.IsRoundDate) { #>
		[Newtonsoft.Json.JsonConverter(typeof(RoundDateJsonConverter))]
<#+					} #>
		public string <#= propertyName #> 
		{ 
			get
			{
				return CurrentLanguageService.GetLocalizedValue(this, "<#= field.PropertyName #>");
			} 
		}
<#+ 
                }
				else
                {
#>
		private <#= field.PropertyTypeName #> <#= fieldName #>;
<#+
if (generation.GenerateDataContractAttributes)
{
#>
		[DataMember]
<#+
}
#>
<#+
if (generation.GenerateMessagePackAttributes)
{
#>
		[MessagePack.Key(<#= fieldIndex #>)]
<#+
}
#>
<#+					if (field.IsRoundDate) { #>
		[Newtonsoft.Json.JsonConverter(typeof(RoundDateJsonConverter))]
<#+					} #>
		[SqlField(DbType.<#= field.DbType #>, <#= field.ColumnSize #><#= field.Precision == 0 || field.Precision == 255 ? string.Empty : ", Precision = " + field.Precision.ToString() #><#= field.Scale == 0 || field.Scale == 255 ? string.Empty : ", Scale=" + field.Scale.ToString() #><#= field.ProviderType.HasValue ? ", ProviderType=" + field.ProviderType.Value.ToString() : string.Empty #><#= field.IsKey ? ", IsKey=true": string.Empty #><#= field.SequenceName == null ? string.Empty : ", SequenceName = \"" + field.SequenceName + "\"" #><#= field.IsAutoIncrement ? ", IsAutoincrement=true": string.Empty #><#= field.IsNullable ? ", AllowNull = true" : string.Empty#><#= field.IsReadOnly ? ", IsReadOnly = true" : string.Empty  #><#= field.ColumnName == null ? string.Empty : ", ColumnName =\"" + field.ColumnName + "\"" #><#= field.BaseColumnName == null ? string.Empty : ", BaseColumnName =\"" + field.BaseColumnName + "\"" #><#= field.BaseTableName == null ? string.Empty : ", BaseTableName = \"" + field.BaseTableName + "\"" #> )]		
		public <#= field.PropertyTypeName #> <#= propertyName #> 
		{ 
		    get { return <#= fieldName #>; } 
			set 
			{
			    <#= fieldName #> = value;
<#+                 if (generation.ImplementINotifyPropertyChanged) { #>
				NotifyPropertyChange("<#=propertyName#>");
<#+					} #>
			}
        }

<#+
				}
			}
			if (generation.GenerateProjectionColumnLists)
			{
				foreach(var kv in generation.ProjectionColumnListsByEntity[entity])
				{
#>
		public const string <#= kv.Key #>ProjectionColumnList = "<#= kv.Value #>";
<#+
				}
			}
#>

	}
<#+
}
#>

<#+  /****************************************************************************************************************************/
void RenderProcedureMethodInRepository(DataLayerGeneration generation, EntitySetting entity, ProcedureSetting procedure)
{
	var proc = generation.GetProcedure(procedure);
	string returnTypeName = procedure.GetReturnTypeName(entity.EntityName);
	string parametersDefinition = DataLayerGeneration.GetProcedureParametersDefinition(proc);
#>

		<#= procedure.MemberVisibility.ToString().ToLower() #> <#= returnTypeName #> <#= Extensions.ToPascalNamingConvention(procedure.ProcedureName) #>(<#= parametersDefinition #>)
		{
<#+
	foreach (var p in proc.Parameters.Cast<IDbDataParameter>().Where( x => (x.Direction & ParameterDirection.Output) == ParameterDirection.Output && x.Direction != ParameterDirection.ReturnValue))
	{
		Type paramType = DataLayerGeneration.GetTypeFromDbType(p.DbType);
		string paramTypeName = paramType.Name;
		string nullableParamTypeName = paramTypeName + (paramType.IsValueType ? "?" : string.Empty);
		string sourceColumn = p.ParameterName;
		if (sourceColumn[0] == '@' || sourceColumn[0] == ':')
		{
			sourceColumn = sourceColumn.Substring(1);
		}
		p.SourceColumn = sourceColumn;
		string argumentName = Extensions.EscapeKeyword(Extensions.ToParameterName( Extensions.ToPascalNamingConvention(sourceColumn)));
		if ((p.Direction & ParameterDirection.Input) ==  ParameterDirection.Input) 
		{
#>
			<#= nullableParamTypeName #> <#= argumentName #>Param = <#= argumentName #>; 
<#+	
		}
	} #>
            var executor = new StoredProcedureExecutor(this.DataService, true)
            {
<#+ if (procedure.CommandTimeout >= 0) { #>
                CommandTimeout = <#=procedure.CommandTimeout #>,
<#+ } #>
                GetCommandFunc = () =>
                {
<#+ if (string.IsNullOrEmpty(procedure.ProcedureSchema) || procedure.ProcedureSchema == generation.DefaultSchema) { #>
                    var proc =  <#= generation.RootNamespace #>.<#= generation.ProceduresClassName #>.<#= procedure.GetCreateProcedureMethodName(generation.DefaultSchema) #>(this.DataService.Connection, this.DataService.EntityLiteProvider.ParameterPrefix, this.DataService.EntityLiteProvider.DefaultSchema);
<#+ } else { #>
                    var proc =  <#= generation.RootNamespace #>.<#= generation.ProceduresClassName #>.<#= procedure.GetCreateProcedureMethodName(generation.DefaultSchema) #>(this.DataService.Connection, this.DataService.EntityLiteProvider.ParameterPrefix);
<#+
	}
	foreach (var p in proc.Parameters.Cast<IDbDataParameter>().Where( x => (x.Direction & ParameterDirection.Input) == ParameterDirection.Input))
	{ 
		string sourceColumn = p.ParameterName;
		if (sourceColumn[0] == '@' || sourceColumn[0] == ':')
		{
			sourceColumn = sourceColumn.Substring(1);
		}
		p.SourceColumn = sourceColumn;
		string argumentName = Extensions.EscapeKeyword(Extensions.ToParameterName(Extensions.ToPascalNamingConvention(sourceColumn)));
		if ((p.Direction & ParameterDirection.Output) == ParameterDirection.Output) argumentName += "Param";

		if (generation.ProviderName == "Devart.Data.Oracle") {
#>
					proc.Parameters["<#= sourceColumn #>"].Value = <#= argumentName #> == null ? (object) DBNull.Value : <#= argumentName #><#= DataLayerGeneration.GetTypeFromDbType(p.DbType).IsValueType ? ".Value" : string.Empty #>;
<#+		} else { #>
					proc.Parameters[this.DataService.EntityLiteProvider.ParameterPrefix + "<#= sourceColumn #>"].Value = <#= argumentName #> == null ? (object) DBNull.Value : <#= argumentName #><#= DataLayerGeneration.GetTypeFromDbType(p.DbType).IsValueType ? ".Value" : string.Empty #>;
<#+		
		}
	}
#>
                    return proc;
                }
            };

<#+
	if (procedure.ResultSetKind == ProcedureResultSetKind.SingleRow)
	{	
#>
			var result = executor.FirstOrDefault<<#= entity.EntityName #>>();				
<#+
	}
	else if (procedure.ResultSetKind == ProcedureResultSetKind.MultipleRows)
	{
#>			
			var result = executor.ToList<<#= entity.EntityName #>>();	
<#+	
	}
	else if (procedure.ResultSetKind == ProcedureResultSetKind.Scalar)
	{
#>
			object result = executor.ExecuteScalar();	
<#+
	}
	else
	{
#>
			executor.ExecuteNonQuery();
<#+
	}
	foreach (var p in proc.Parameters.Cast<IDbDataParameter>().Where( x => (x.Direction & ParameterDirection.Output) == ParameterDirection.Output && x.Direction != ParameterDirection.ReturnValue))
	{
		Type paramType = DataLayerGeneration.GetTypeFromDbType(p.DbType);
		string paramTypeName = paramType.Name;
		string nullableParamTypeName = paramTypeName + (paramType.IsValueType ? "?" : string.Empty);
#>
			<#= Extensions.EscapeKeyword(Extensions.ToParameterName(Extensions.ToPascalNamingConvention( p.SourceColumn))) #> = (<#= nullableParamTypeName #>) executor.OutputParameterValues["<#= p.SourceColumn #>"]; 
<#+
	}				
	switch (procedure.ResultSetKind)
	{	
		case ProcedureResultSetKind.MultipleRows:
#>
			return result;
<#+
		break;
		case ProcedureResultSetKind.SingleRow:
#>
			return result;
<#+
		break;
		case ProcedureResultSetKind.Scalar:				
#>
			return (result == DBNull.Value || result == null) ? default(<#= Extensions.ActualName(procedure.ScalarReturnType) #>) : (<#= Extensions.ActualName(procedure.ScalarReturnType) #>) Convert.ChangeType(result, typeof(<#= Extensions.UndelyingType(procedure.ScalarReturnType).Name #>));
<#+
		break;
	}
#>
		}
<#+
}
#>

<#+  /****************************************************************************************************************************/
void RenderProcedureAsyncMethodInRepository(DataLayerGeneration generation, EntitySetting entity, ProcedureSetting procedure)
{
	if (generation.GenerateAsyncMethods == false) return;
	var proc = generation.GetProcedure(procedure);
	if (proc.Parameters.Cast<IDbDataParameter>().Any( x => (x.Direction & ParameterDirection.Output) == ParameterDirection.Output && x.Direction != ParameterDirection.ReturnValue)) {
	 return;
	}
	string returnTypeName = procedure.GetReturnTypeName(entity.EntityName);
	string parametersDefinition = DataLayerGeneration.GetProcedureParametersDefinition(proc);
	string methodReturnTypeName = returnTypeName == "void" ? "System.Threading.Tasks.Task" : "System.Threading.Tasks.Task<" + returnTypeName + ">";
#>

		<#= procedure.MemberVisibility.ToString().ToLower() #> async <#= methodReturnTypeName #> <#= Extensions.ToPascalNamingConvention(procedure.ProcedureName) #>Async(<#= parametersDefinition #>)
		{
<#+
	foreach (var p in proc.Parameters.Cast<IDbDataParameter>().Where( x => (x.Direction & ParameterDirection.Output) == ParameterDirection.Output && x.Direction != ParameterDirection.ReturnValue))
	{
		Type paramType = DataLayerGeneration.GetTypeFromDbType(p.DbType);
		string paramTypeName = paramType.Name;
		string nullableParamTypeName = paramTypeName + (paramType.IsValueType ? "?" : string.Empty);
		string sourceColumn = p.ParameterName;
		if (sourceColumn[0] == '@' || sourceColumn[0] == ':')
		{
			sourceColumn = sourceColumn.Substring(1);
		}
		p.SourceColumn = sourceColumn;
		string argumentName = Extensions.EscapeKeyword(Extensions.ToParameterName(Extensions.ToPascalNamingConvention(sourceColumn)));
		if ((p.Direction & ParameterDirection.Input) ==  ParameterDirection.Input) 
		{
#>
			<#= nullableParamTypeName #> <#= argumentName #>Param = <#= argumentName #>; 
<#+	
		}
	} #>
            var executor = new StoredProcedureExecutor(this.DataService, true)
            {
<#+ if (procedure.CommandTimeout >= 0) { #>
                CommandTimeout = <#=procedure.CommandTimeout #>,
<#+ } #>
                GetCommandFunc = () =>
                {
<#+ if (string.IsNullOrEmpty(procedure.ProcedureSchema) || procedure.ProcedureSchema == generation.DefaultSchema) { #>
                    var proc =  <#= generation.RootNamespace #>.<#= generation.ProceduresClassName #>.<#= procedure.GetCreateProcedureMethodName(generation.DefaultSchema) #>(this.DataService.Connection, this.DataService.EntityLiteProvider.ParameterPrefix, this.DataService.EntityLiteProvider.DefaultSchema);
<#+ } else { #>
                    var proc =  <#= generation.RootNamespace #>.<#= generation.ProceduresClassName #>.<#= procedure.GetCreateProcedureMethodName(generation.DefaultSchema) #>(this.DataService.Connection, this.DataService.EntityLiteProvider.ParameterPrefix);
<#+ 
	}
	foreach (var p in proc.Parameters.Cast<IDbDataParameter>().Where( x => (x.Direction & ParameterDirection.Input) == ParameterDirection.Input))
	{ 
		string sourceColumn = p.ParameterName;
		if (sourceColumn[0] == '@' || sourceColumn[0] == ':')
		{
			sourceColumn = sourceColumn.Substring(1);
		}
		p.SourceColumn = sourceColumn;
		string argumentName = Extensions.EscapeKeyword(Extensions.ToParameterName(Extensions.ToPascalNamingConvention(sourceColumn)));
		if ((p.Direction & ParameterDirection.Output) == ParameterDirection.Output) argumentName += "Param";
		if (generation.ProviderName == "Devart.Data.Oracle") {
#>
					proc.Parameters["<#= sourceColumn #>"].Value = <#= argumentName #> == null ? (object) DBNull.Value : <#= argumentName #><#= DataLayerGeneration.GetTypeFromDbType(p.DbType).IsValueType ? ".Value" : string.Empty #>;
<#+		} else { #>
					proc.Parameters[this.DataService.EntityLiteProvider.ParameterPrefix + "<#= sourceColumn #>"].Value = <#= argumentName #> == null ? (object) DBNull.Value : <#= argumentName #><#= DataLayerGeneration.GetTypeFromDbType(p.DbType).IsValueType ? ".Value" : string.Empty #>;
<#+		
		}
	}
#>
                    return proc;
                }
            };

<#+
	if (procedure.ResultSetKind == ProcedureResultSetKind.SingleRow)
	{	
#>
			var result = await executor.FirstOrDefaultAsync<<#= entity.EntityName #>>().ConfigureAwait(false);				
<#+
	}
	else if (procedure.ResultSetKind == ProcedureResultSetKind.MultipleRows)
	{
#>			
			var result = await executor.ToListAsync<<#= entity.EntityName #>>().ConfigureAwait(false);
<#+	
	}
	else if (procedure.ResultSetKind == ProcedureResultSetKind.Scalar)
	{
#>
			object result = await executor.ExecuteScalarAsync().ConfigureAwait(false);	
<#+
	}
	else
	{
#>
			await executor.ExecuteNonQueryAsync().ConfigureAwait(false);
<#+
	}
	foreach (var p in proc.Parameters.Cast<IDbDataParameter>().Where( x => (x.Direction & ParameterDirection.Output) == ParameterDirection.Output && x.Direction != ParameterDirection.ReturnValue))
	{
		Type paramType = DataLayerGeneration.GetTypeFromDbType(p.DbType);
		string paramTypeName = paramType.Name;
		string nullableParamTypeName = paramTypeName + (paramType.IsValueType ? "?" : string.Empty);
#>
			<#= Extensions.EscapeKeyword(Extensions.ToParameterName(Extensions.ToPascalNamingConvention(p.SourceColumn))) #> = (<#= nullableParamTypeName #>) executor.OutputParameterValues["<#= p.SourceColumn #>"]; 
<#+
	}				
	switch (procedure.ResultSetKind)
	{	
		case ProcedureResultSetKind.MultipleRows:
#>
			return result;
<#+
		break;
		case ProcedureResultSetKind.SingleRow:
#>
			return result;
<#+
		break;
		case ProcedureResultSetKind.Scalar:				
#>
			return (result == DBNull.Value || result == null) ? default(<#= Extensions.ActualName(procedure.ScalarReturnType) #>) : (<#= Extensions.ActualName(procedure.ScalarReturnType) #>) Convert.ChangeType(result, typeof(<#= Extensions.UndelyingType(procedure.ScalarReturnType).Name #>));
<#+
		break;
	}
#>
		}
<#+
}
#>

<#+ /****************************************************************************************************************************/
void RenderEntityRepositoryClass(DataLayerGeneration generation, EntitySetting entity)
{
#>

	public partial class <#=  entity.EntityName #>Repository : Repository<<#= entity.EntityName #>> 
	{
		public <#= entity.EntityName #>Repository(DataService DataService) : base(DataService)
		{
		}

		public new <#= generation.DataServiceName #>  DataService  
		{
			get { return (<#= generation.DataServiceName #>) base.DataService; }
			set { base.DataService = value; }
		}

<#+ 
	var primaryKey = generation.GetPrimaryKey(entity);
	FieldMetadata primaryKeyField = primaryKey.Count == 1 ? primaryKey[0] : null;
	if (primaryKeyField != null)
    {
		string primaryKeyParameterName = Extensions.ToParameterName(primaryKeyField.PropertyName);
#>
		public <#= entity.EntityName #> Get(string projectionName, <#=primaryKeyField.PropertyTypeName #> <#= primaryKeyParameterName #>)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).Get(projectionName, <#= primaryKeyParameterName #>, FetchMode.UseIdentityMap);
		}

		public <#= entity.EntityName #> Get(string projectionName, <#=primaryKeyField.PropertyTypeName #> <#= primaryKeyParameterName #>, FetchMode fetchMode = FetchMode.UseIdentityMap)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).Get(projectionName, <#= primaryKeyParameterName #>, fetchMode);
		}

		public <#= entity.EntityName #> Get(Projection projection, <#=primaryKeyField.PropertyTypeName #> <#= primaryKeyParameterName #>)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).Get(projection, <#= primaryKeyParameterName #>, FetchMode.UseIdentityMap);
		}

		public <#= entity.EntityName #> Get(Projection projection, <#=primaryKeyField.PropertyTypeName #> <#= primaryKeyParameterName #>, FetchMode fetchMode = FetchMode.UseIdentityMap)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).Get(projection, <#= primaryKeyParameterName #>, fetchMode);
		}

		public <#= entity.EntityName #> Get(string projectionName, <#=primaryKeyField.PropertyTypeName #> <#= primaryKeyParameterName #>, params string[] fields)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).Get(projectionName, <#=primaryKeyParameterName #>, fields);
		}

		public <#= entity.EntityName #> Get(Projection projection, <#=primaryKeyField.PropertyTypeName #> <#= primaryKeyParameterName #>, params string[] fields)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).Get(projection, <#=primaryKeyParameterName #>, fields);
		}

		public bool Delete(<#=primaryKeyField.PropertyTypeName #> <#=primaryKeyParameterName #>)
		{
			var entity = new <#= entity.EntityName #> { <#=primaryKeyField.PropertyName #> = <#=primaryKeyParameterName #> };
			return this.Delete(entity);
		}

		<#+ if (generation.GenerateAsyncMethods) { #>
		// asyncrhonous methods

		public System.Threading.Tasks.Task<<#= entity.EntityName #>> GetAsync(string projectionName, <#=primaryKeyField.PropertyTypeName #> <#=primaryKeyParameterName #>)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).GetAsync(projectionName, <#=primaryKeyParameterName #>, FetchMode.UseIdentityMap);
		}

		public System.Threading.Tasks.Task<<#= entity.EntityName #>> GetAsync(string projectionName, <#=primaryKeyField.PropertyTypeName #> <#=primaryKeyParameterName #>, FetchMode fetchMode = FetchMode.UseIdentityMap)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).GetAsync(projectionName, <#=primaryKeyParameterName #>, fetchMode);
		}

		public System.Threading.Tasks.Task<<#= entity.EntityName #>> GetAsync(Projection projection, <#=primaryKeyField.PropertyTypeName #> <#=primaryKeyParameterName #>)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).GetAsync(projection, <#=primaryKeyParameterName #>, FetchMode.UseIdentityMap);
		}

		public System.Threading.Tasks.Task<<#= entity.EntityName #>> GetAsync(Projection projection, <#=primaryKeyField.PropertyTypeName #> <#=primaryKeyParameterName #>, FetchMode fetchMode = FetchMode.UseIdentityMap)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).GetAsync(projection, <#=primaryKeyParameterName #>, fetchMode);
		}

		public System.Threading.Tasks.Task<<#= entity.EntityName #>> GetAsync(string projectionName, <#=primaryKeyField.PropertyTypeName #> <#=primaryKeyParameterName #>, params string[] fields)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).GetAsync(projectionName, <#=primaryKeyParameterName #>, fields);
		}

		public System.Threading.Tasks.Task<<#= entity.EntityName #>> GetAsync(Projection projection, <#=primaryKeyField.PropertyTypeName #> <#=primaryKeyParameterName #>, params string[] fields)
		{
			return ((IRepository<<#= entity.EntityName #>>)this).GetAsync(projection, <#=primaryKeyParameterName #>, fields);
		}

		public System.Threading.Tasks.Task<bool> DeleteAsync(<#=primaryKeyField.PropertyTypeName #> <#=primaryKeyParameterName #>)
		{
			var entity = new <#= entity.EntityName #> { <#=primaryKeyField.PropertyName #> = <#=primaryKeyParameterName #> };
			return this.DeleteAsync(entity);
		}
		<#+ } #>

<#+
    }
		var procedures = generation.GetRelatedProcedures(entity.EntityName, entity.Schema);
		if (procedures != null && procedures.Count > 0)
		{
			foreach (var procedure in procedures)
			{
				RenderProcedureMethodInRepository(generation, entity, procedure);
				RenderProcedureAsyncMethodInRepository(generation, entity, procedure);
			}
		}
#>
	}
<#+
}
#>

<#+ /****************************************************************************************************************************/
void RenderEntityFieldsClass(DataLayerGeneration generation, EntitySetting entity)
{
#>
	[Obsolete("Use nameof instead")]
	public static partial class <#= entity.EntityName #>Fields
	{
<#+ 
	foreach (var field in generation.GetFieldsMetadata(entity))
    {
#>
		public const string <#= Extensions.EscapeKeyword(field.PropertyName) #> = "<#= field.PropertyName #>";
<#+
    }
#>
	}

<#+
}
#>

<#+ /****************************************************************************************************************************/
void RenderProjectionClass(DataLayerGeneration generation, EntitySetting entity)
{
#>
	public static partial class <#= entity.EntityName #>Projections
	{
<#+
		foreach(var kv in generation.ProjectionColumnListsByEntity[entity])
		{
#>
		public const string <#= kv.Key #> = "<#= kv.Key #>";
<#+
		}
#>
	}
<#+
}
#>﻿<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.Common" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace= "System.Data.SqlClient" #>
<#@ import namespace= "System.Data.SqlTypes" #>
<#@ output extension=".cs" #>
<#@ include file ="Extensions.ttinclude" #>
<#@ include file ="Sequence.ttinclude" #>
<#@ include file ="TextTransform.ttinclude" #>
<#@ include file ="JsonType.ttinclude" #>
<#@ include file ="DataLayerGeneration.ttinclude" #>
<#@ include file ="DataServiceGeneration.ttinclude" #>
<#@ include file ="EntityGeneration.ttinclude" #>
<#@ include file ="EntitySetting.ttinclude" #>
<#@ include file ="FieldGeneration.ttinclude" #>
<#@ include file ="FieldMetadata.ttinclude" #>
<#@ include file ="EnumSetting.ttinclude" #>
<#@ include file ="EnumGeneration.ttinclude" #>
<#@ include file ="MemberVisibility.ttinclude" #>
<#@ include file ="ProcedureGeneration.ttinclude" #>
<#@ include file ="ProcedureResultSetKind.ttinclude" #>
<#@ include file ="ProcedureSetting.ttinclude" #>
<#@ include file ="TypeScriptAttributeGeneration.ttinclude" #>
<#@ include file ="RoundDateJsonConverterGeneration.ttinclude" #>
<#+ 
	void Render(DataLayerGeneration generation)
	{
		using (generation)
        {
            generation.Initialize();
            EntityGeneration_Render(generation);
			EnumGeneration_Render(generation);
            DataServiceGeneration_Render(generation);
            ProcedureGeneration_Render(generation);
			TypeScriptAttributeGeneration_Render(generation);
			RoundDateJsonConverterGeneration_Render(generation);
        }
	}
#>﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public class EntitySetting
{
    public string BaseTableName { get; set; }
    public string Schema { get; set; }
    public string ReadOnlyFields { get; set; }
    public string EntityName { get; set; }
	public string SequenceName { get; set;}
	public bool? GenerateTypeScript { get; set;}
	public string SynonymName {get; set;}
	public string SynonymSchema {get; set;}
	public string RoundDateFields {get; set;}
	public bool IsAuditable {get; set;}
	public string FieldPrefix {get; set;}
	public string RemoveFieldPrefixes {get; set;}
	public Dictionary<string, string> ColumnToPropertyMap {get; set;}

    public int EntityTypeId { get; internal set; }

    private string _parentPropertyName;
    public string ParentPropertyName
    {
        get { return _parentPropertyName; }
        set
        {
            if (value == "Application") _parentPropertyName = "__Application__";
            else { _parentPropertyName = value; }
        }
    }

	public string GetSqlEntityParameters(string defaultSchema)
	{
		string parameters = string.Empty;
		if (!string.IsNullOrEmpty(BaseTableName))
		{
			parameters = "BaseTableName=\"" + BaseTableName + "\"";
		}
		if (!string.IsNullOrEmpty(Schema) && Schema != defaultSchema )
		{
			if (!string.IsNullOrEmpty(parameters)) parameters += ", ";
			parameters += "SchemaName=\"" + Schema + "\"";
		}
		if (IsAuditable) parameters += ", IsAuditable = true";
		if (!string.IsNullOrEmpty(FieldPrefix)) parameters += ", FieldPrefix = \"" + FieldPrefix + "\"";
		return parameters;
	}

    public string GetFullTableName(string defaultSchema, string  quotePrefix, string quoteSufix)
    {
        if (string.IsNullOrEmpty(BaseTableName)) return string.Empty;
		string schema = this.Schema;
		if (string.IsNullOrEmpty(schema)) schema = defaultSchema;
		return string.IsNullOrEmpty(schema) ? quotePrefix + BaseTableName + quoteSufix: quotePrefix +  schema + quoteSufix + "." + quotePrefix + BaseTableName + quoteSufix ;
    }

	public string GetFullObjectName(string defaultSchema, string  quotePrefix, string quoteSufix)
	{
		if (string.IsNullOrEmpty(SynonymName)) return GetFullTableName(defaultSchema, quotePrefix, quoteSufix);
		string schema = this.SynonymSchema;
		if (string.IsNullOrEmpty(schema)) schema = defaultSchema;
		return string.IsNullOrEmpty(schema) ? quotePrefix + SynonymName + quoteSufix: quotePrefix +  schema + quoteSufix + "." + quotePrefix + SynonymName + quoteSufix ;
	}

    public static string GetFullEntityName(string entityName, string schema, string defaultSchema)
    {
		
        if (string.IsNullOrEmpty(schema) || schema == defaultSchema)
        {
            return entityName;
        }
        else
        {
            return Extensions.ToPascalNamingConvention(schema) + "." + entityName;
        }
    }

    public string FullEntityName
    {
        get
        {
            return GetFullEntityName(EntityName, Schema, null);
        }
    }

    public string GetNamespaceName(string rootNamespace)
    {
        string namespaceName = rootNamespace;
        if (!string.IsNullOrEmpty(this.Schema))
        {
            namespaceName += "." + Extensions.ToPascalNamingConvention(this.Schema);
        }
        return namespaceName;
    }

    public string GetRepositoryPropertyName()
    {
        if (!string.IsNullOrEmpty(this.Schema))
        {
            return Extensions.ToPascalNamingConvention(this.Schema) + this.EntityName + "Repository";
        }
        else
        {
            return this.EntityName + "Repository";
        }
    }

    public HashSet<string> GetReadOnlyFields()
    {
        HashSet<string> readOnlyFields = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);
        if (this.ReadOnlyFields == null) return readOnlyFields;
        foreach (string token in this.ReadOnlyFields.Split(','))
        {
            string fieldName = token.Trim();
            if (!string.IsNullOrEmpty(fieldName))
            {
                readOnlyFields.Add(fieldName);
            }
        }
        return readOnlyFields;
    }

	public HashSet<string> GetRoundDateFields()
	{
        HashSet<string> roundDateFields = new HashSet<string>(StringComparer.InvariantCultureIgnoreCase);
        if (this.RoundDateFields == null) return roundDateFields;
        foreach (string token in this.RoundDateFields.Split(','))
        {
            string fieldName = token.Trim();
            if (!string.IsNullOrEmpty(fieldName))
            {
                roundDateFields.Add(fieldName);
            }
        }
        return roundDateFields;		
	}


    public FieldGeneration FieldGeneration { get; set; }

    public EntitySetting()
    {
        FieldGeneration = FieldGeneration.ForBaseTableAndViews;
    }
}
#>

﻿<#+
/**
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
void EnumGeneration_Render(DataLayerGeneration generation)
{	
	if (generation.EnumSettings == null || generation.EnumSettings.Count == 0) return;
	var nsgs = from enumSetting in generation.EnumSettings
			group enumSetting by enumSetting.GetNamespaceName(generation.RootNamespace) into g
			select g;
	foreach (var g in nsgs)
    {
		string namespaceName = g.Key;
#>

namespace <#= namespaceName #>
{
<#+
		foreach (var enumSetting in g)
		{
			RenderEnumType(generation, enumSetting);
		}
	
#>
}
<#+
	}
}
#>


<#+ /** ************************************************************************************************************************ **/
public void RenderEnumType(DataLayerGeneration generation, EnumSetting enumSetting)
{
	if (generation.GenerateTypeScript) {
#>
	[TypeScript] 
<#+ } #>
	public enum <#= Extensions.EscapeKeyword(enumSetting.TypeName) #>
	{
<#+ using (var cn = generation.OpenConnection())
	using (var cmd = cn.CreateCommand())
	{
		var prefix = generation.CommandBuilder.QuotePrefix;
		var sufix = generation.CommandBuilder.QuoteSuffix;
		cmd.CommandText = "SELECT " + prefix + enumSetting.IdField + sufix + ", " + prefix + enumSetting.NameField + sufix + " FROM " + enumSetting.GetFullTableName(generation.DefaultSchema, prefix, sufix);
		using (var reader = cmd.ExecuteReader())
		{
			while (reader.Read())
			{
				var memberValue = reader.GetValue(0);
				var memberName = reader.GetString(1);
				if (!enumSetting.Predicate(memberName)) continue;
				memberName = enumSetting.StringFilter(memberName);
				memberName = Extensions.EscapeKeyword(Extensions.ToPascalNamingConvention(memberName));
#>
		<#= memberName #> = <#= memberValue.ToString() #>,
<#+			}
		}
	}
#>
	}
<#+
}
#>﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public class EnumSetting
{
    public string BaseTableName { get; set; }
    public string Schema { get; set; }
	public string IdField { get; set;}
	public string NameField { get; set;}
	public string Namespace {get; set;}

	public Func<string, bool> Predicate;

	public Func<string, string> StringFilter;

	private string _typeName;
	public string TypeName { 
		get {
			if (_typeName == null && IdField != null) {
				_typeName = Extensions.ToPascalNamingConvention(IdField);
			}
			return _typeName;
		}
		set {
			_typeName = value;
		}
	}

	public EnumSetting() 
	{
		Predicate = _ => true;
		StringFilter = name => name;
	}


    public string GetFullTableName(string defaultSchema, string  quotePrefix, string quoteSufix)
    {
        if (string.IsNullOrEmpty(BaseTableName)) return string.Empty;
		string schema = this.Schema;
		if (string.IsNullOrEmpty(schema)) schema = defaultSchema;
		return string.IsNullOrEmpty(schema) ? quotePrefix + BaseTableName + quoteSufix: quotePrefix +  schema + quoteSufix + "." + quotePrefix + BaseTableName + quoteSufix ;
    }

    public string GetNamespaceName(string rootNamespace)
    {
        string namespaceName = rootNamespace;
		if (this.Namespace != null)
		{
		    if (this.Namespace != String.Empty)
			{
				namespaceName += "." + Extensions.ToPascalNamingConvention(this.Namespace);
			}
		}
        else if (!string.IsNullOrEmpty(this.Schema))
        {
            namespaceName += "." + Extensions.ToPascalNamingConvention(this.Schema);
        }
        return namespaceName;
    }

	public string GetFullIdField() 
	{
		string prefix = string.Empty;
		if (this.Namespace != null)
		{
			if (this.Namespace != String.Empty)
			{
				prefix = Extensions.ToPascalNamingConvention(this.Namespace) + ".";
			}
		}
        else if (!string.IsNullOrEmpty(this.Schema))
        {
            prefix = Extensions.ToPascalNamingConvention(this.Schema) + ".";
        }
		return prefix + Extensions.ToPascalNamingConvention(IdField);
	}
}
#>

﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public static class Extensions
{
		public static IDictionary<TKey, IList<TItem>> ToListDictionary<TKey, TItem>( IEnumerable<TItem> itemsSource, Func<TItem, TKey> keySelector)
		{
            IDictionary<TKey, IList<TItem>> dic;
            if (typeof(TKey) == typeof(string))
            {
                dic =  new Dictionary<TKey, IList<TItem>>((IEqualityComparer<TKey>) StringComparer.CurrentCultureIgnoreCase);
            }
            else
            {
                dic = new Dictionary<TKey, IList<TItem>>();
            }
			
			foreach (var item in itemsSource)
			{
				IList<TItem> list = null;
				TKey key = keySelector(item);
				if (!dic.TryGetValue(key, out list))
				{
					list = new List<TItem>();
					dic.Add(key, list);
				}
				list.Add(item);

			}
			return dic;
		}

		public static void SetPropertyValue( object obj, string propertyName, object value) {
			var type = obj.GetType();
			var prop = type.GetProperty(propertyName);
			prop.SetValue(obj, value);
		}

		        public static string ToPascalNamingConvention( string str)
        {
            StringBuilder sb = new StringBuilder(str.Length);
            bool isPreviousLower = false;
            bool isNewWord = true;
            for (int i = 0; i < str.Length; i++)
            {
                char c = str[i];
                if (c == ' ' || c == '_' || c == '.')
                {
                    isNewWord = true;
                    continue;
                }
                bool isUpper = char.IsUpper(c);
                bool isLower = char.IsLower(c);
                bool isNextLower = i < str.Length -1 &&  char.IsLower(str[i+1]);

                if ( isUpper && (isPreviousLower || isNextLower))
                {
                    isNewWord = true;
                }
                if (isNewWord)
                {
                    isNewWord = false;
                    if (isLower) c = char.ToUpper(c);
                }
                else
                {
                    if (isUpper) c = char.ToLower(c);
                }
                isPreviousLower = isLower;
                sb.Append(c);
            }
            return sb.ToString();
        }


        public static string ToUnderscoreLowerCaseNamingConvention( string str)
        {
            StringBuilder sb = new StringBuilder(str.Length + 6);
            bool isPreviousCharLowerCase = false;
            for (int i = 0; i < str.Length; i++ )
            {
                char c = str[i];
                bool isUpper = char.IsUpper(c);
                if (isPreviousCharLowerCase && isUpper)
                {
                    sb.Append('_');
                }
                if (c == ' ') c = '_';
                isPreviousCharLowerCase = char.IsLower(c);
                if (isUpper) c = char.ToLower(c);
                sb.Append(c);
            }
            return sb.ToString();
        }

        public static string ToUnderscoreUpperCaseNamingConvention( string str)
        {
            StringBuilder sb = new StringBuilder(str.Length + 8);
            bool isPreviousCharLowerCase = false;
            for (int i = 0; i < str.Length; i++)
            {
                char c = str[i];
                bool isLower = char.IsLower(c);
                if (isPreviousCharLowerCase && char.IsUpper(c))
                {
                    sb.Append('_');
                }
                if (c == ' ') c = '_';
                isPreviousCharLowerCase = isLower;
                if (isLower) c = char.ToUpper(c);
                sb.Append(c);
            }
            return sb.ToString();
        }

        public static bool HasUpperAndLowerCaseChars( string str)
        {
            bool hasLower = false;
            bool hasUpper = false;
            foreach(char c in str)
            {
                if (!hasLower && char.IsLower(c)) hasLower = true;
                if (!hasUpper && char.IsUpper(c)) hasUpper = true;
                if (hasLower && hasUpper) return true;
            }
            return false;
        }

        public static string Transform( string str, TextTransform textTransform)
        {
            switch (textTransform)
            {
                case TextTransform.None:
                    return str;
                case TextTransform.ToLower:
                    return str.ToLower();
                case TextTransform.ToUpper:
                    return str.ToUpper();
                case TextTransform.ToPascalNamingConvention:
                    return ToPascalNamingConvention(str);
                case TextTransform.ToUnderscoreLowerCaseNamingConvention:
                    return ToUnderscoreLowerCaseNamingConvention(str);
                case TextTransform.ToUnderscoreUpperCaseNamingConvention:
                    return ToUnderscoreUpperCaseNamingConvention(str);
                default:
                    throw new NotImplementedException();
            }
        }

		        private static readonly HashSet<string> Keywords = new HashSet<string>
		{
			"abstract", "add", "alias", "as", "ascending", "async", "await", "base", 
			"bool", "break", "byte", "case", "catch", "char", "checked", "class", 
			"const", "continue", "decimal", "default", "delegate", "descending",
			"do", "double", "dynamic", "else", "enum", "event", "explicit", "extern", 
			"false", "finally", "fixed", "float", "for", "foreach", "from", "get", 
			"global", "goto", "group", "if", "implicit", "into","in", "int", 
			"interface", "internal", "is", "join", "let", "lock", "long", "namespace", 
			"new", "null", "object", "operator", "out", "orderby", "override", "params", 
			"partial", "private", "protected", "public", "readonly", "ref",  "remove", 
			"return", "sbyte", "sealed", "select", "set", "short", "sizeof", "stackalloc", 
			"static", "string", "struct", "switch", "this", "throw", "true", "try", 
			"typeof", "uint", "ulong", "unckecked", "unsafe", "ushort", "using", 
			"value", "var", "where", "virtual", "void", "volatile", "while", "yield"
		};

        public static string EscapeKeyword( string str)
        {
            if (Keywords.Contains(str))
            {
                return "@" + str;
            }
            else
            {
                return str;
            }
        }

        public static string ActualName( Type type)
        {
            if (!type.IsGenericType)
                return type.Name;
            string genericTypeName = type.GetGenericTypeDefinition().Name;
            genericTypeName = genericTypeName.Substring(0,
                genericTypeName.IndexOf('`'));
            string genericArgs = string.Join(",",
                type.GetGenericArguments()
                    .Select(ta => ActualName(ta)).ToArray());
            return genericTypeName + "<" + genericArgs + ">";
        }

        public static bool IsNullableValueType( Type type)
        {
            return (type.IsGenericType && type.IsValueType && type.GetGenericTypeDefinition() == typeof(Nullable<>));
        }


        public static string ToParameterName( string self)
        {
            if (string.IsNullOrEmpty(self)) throw new ArgumentException("parameter cannot be null nor empty", "self");

            string firstCharacter = self.Substring(0, 1).ToLower();
            if (self.Length > 1)
            {
                return firstCharacter + self.Substring(1);
            }
            else
            {
                return firstCharacter;
            }
        }

		/*
        static readonly System.Text.RegularExpressions.Regex parameterRegex = new System.Text.RegularExpressions.Regex(@"\$\((\S)+\)",  System.Text.RegularExpressions.RegexOptions.Compiled);

        internal static string GetSql( ISqlTemplate template, string parameterPrefix)
        {
            var sql = parameterRegex.Replace(template.TransformText(),
                (match) => parameterPrefix + match.Value.Substring(2, match.Value.Length - 3));

            return sql;
        }
		*/



		public static Type UndelyingType( Type type)
		{
			if (IsNullableValueType(type))
			{
				return type.GetGenericArguments()[0];
			}
			else
			{
				return type;
			}
		}
}
#>﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public enum FieldGeneration
{
    ForBaseTable = 1,
    ForViews = 2,
    ForBaseTableAndViews = 3
}
#>
﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public class FieldMetadata
{
    public bool IsNullable { get; set; }
    public string PropertyName { get; set; }
    public DbType DbType { get; set; }
    public Type PropertyType { get; set; }
    public bool IsAutoIncrement { get; set; }
    public bool IsReadOnly { get; set; }
    public bool IsKey { get; set; }
    public byte Precision { get; set; }
    public byte Scale { get; set; }
    public string BaseColumnName { get; set; }
    public string BaseSchemaName { get; set; }
    public string BaseTableName { get; set; }
	public string ColumnName {get; set;}
    public int ColumnSize { get; set; }
    public bool IsLocalizedField { get; set; }
	public string SequenceName { get; set;}
	public string PropertyTypeName { get; set;}
	public int? ProviderType {get; set;}
	public bool IsRoundDate {get; set;}

    public string FullTableName(string quotePrefix, string quoteSufix)
    {
        if ( string.IsNullOrEmpty(BaseTableName)) return null;
        if (!string.IsNullOrEmpty(BaseSchemaName)) return quotePrefix + BaseSchemaName + quoteSufix + "." + quotePrefix + BaseTableName + quoteSufix;
        return quotePrefix + BaseTableName + quoteSufix;
    }
}
#>﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public enum JsonType
{
	None = 0,
    JToken= 1,
    JObject = 2
}
#>
﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public enum MemberVisibility
{
    Public = 0,
    Private,
    Internal
}
#>﻿<#+ 
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
void ProcedureGeneration_Render(DataLayerGeneration generation)
{	
    if (generation.ProcedureSettings == null || generation.ProcedureSettings.Count == 0) return;
#>
namespace <#= generation.RootNamespace #>
{
	public static partial class <#= generation.ProceduresClassName #>
	{
<#+
	foreach(var procedure in generation.ProcedureSettings)
	{
		var proc = generation.GetProcedure(procedure);
#>
		public static DbCommand <#= procedure.GetCreateProcedureMethodName(generation.DefaultSchema) #>(DbConnection connection, string parameterPrefix, string schema = "<#= string.IsNullOrEmpty(procedure.ProcedureSchema) ? string.Empty : procedure.ProcedureSchema #>")
		{
			var cmd = connection.CreateCommand();
			cmd.CommandText = string.IsNullOrEmpty(schema) ? "<#= procedure.ProcedureName #>" : schema + "." + "<#= procedure.ProcedureName #>";
			cmd.CommandType = CommandType.StoredProcedure;
			IDbDataParameter p = null;
<#+
        bool isFirstRefCursor= true;
		foreach(IDbDataParameter p in proc.Parameters)
		{
			string sourceColumn = p.ParameterName;
			if (!string.IsNullOrEmpty(sourceColumn) && (sourceColumn[0] == '@' || sourceColumn[0] == ':'))
			{
				sourceColumn = sourceColumn.Substring(1);
			}
            var oracleDbTypeProp = p.GetType().GetProperty("OracleDbType");
            bool isRefCursor = oracleDbTypeProp != null && oracleDbTypeProp.GetValue(p, null).ToString() == "RefCursor";
            if (isFirstRefCursor && isRefCursor)
            {
                    isFirstRefCursor = false;
 #>

            Type paramType = p.GetType();
            var oracleDbTypeProperty = paramType.GetProperty("OracleDbType");
            var refCursorValue = Enum.Parse(oracleDbTypeProperty.PropertyType, "RefCursor");
<#+         
            }  
#>

			p = cmd.CreateParameter();
			p.ParameterName = parameterPrefix + "<#= sourceColumn #>";
<#+ 
            if (isRefCursor)
            {
#>
            oracleDbTypeProperty.SetValue(p, refCursorValue, null);
<#+         } 
            else {
#>
			p.DbType = DbType.<#= p.DbType.ToString() #>;
<#+         
            } #>
            p.Direction = ParameterDirection.<#= p.Direction.ToString() #>;
<#+
			if (p.Size != 0) 
			{
#>
			p.Size = <#= p.Size.ToString() #>;
<#+
			}
			if (p.Precision != 0)
			{
#>
			p.Precision = <#= p.Precision.ToString() #>;
<#+
			}
			if (p.Scale != 0)
			{
#>
			p.Scale = <#= p.Scale.ToString() #>;
<#+
			}
			if (!string.IsNullOrEmpty(sourceColumn))
			{
#>
			p.SourceColumn = "<#= sourceColumn #>";
<#+
			}
#>
			cmd.Parameters.Add(p);
<#+
		}
#>

			return cmd;
		}

<#+
	}
#>
	}
}
<#+
}
#>﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public enum ProcedureResultSetKind
{
    None,
    Scalar,
    SingleRow,
    MultipleRows
}
#>﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public class ProcedureSetting
{
    public string ProcedureName { get; set; }
    public string ProcedureSchema { get; set; }

    public Type ScalarReturnType { get; set; }

    public MemberVisibility MemberVisibility { get; set; }

    public int CommandTimeout { get; set; }

    public string GetFullProcedureName()
    {
        if (string.IsNullOrEmpty(ProcedureName)) return string.Empty;
        if (!string.IsNullOrEmpty(ProcedureSchema))
        {
            return ProcedureSchema + "." + ProcedureName;
        }
        else
        {
            return ProcedureName;
        }
    }

    public string GetCreateProcedureMethodName(string defaultSchema)
    {
        if (!string.IsNullOrEmpty(this.ProcedureSchema) && this.ProcedureSchema != defaultSchema)
        {
            return "Create" + Extensions.ToPascalNamingConvention(this.ProcedureSchema) + Extensions.ToPascalNamingConvention(this.ProcedureName) + "Procedure";
        }
        else
        {
            return "Create" +  Extensions.ToPascalNamingConvention(this.ProcedureName) + "Procedure";
        }
    }

    public ProcedureResultSetKind ResultSetKind { get; set; }

    public string RelatedEntityName { get; set; }
    public string RelatedEntitySchema { get; set; }

    public ProcedureSetting()
    {
        this.CommandTimeout = -1;
    }

    public string GetReturnTypeName(string entityName)
    {

        switch (ResultSetKind)
        {
            case ProcedureResultSetKind.None:
                return "void";
            case ProcedureResultSetKind.Scalar:                 
                return Extensions.ActualName(ScalarReturnType);
            case ProcedureResultSetKind.SingleRow:
                return entityName;
            case ProcedureResultSetKind.MultipleRows:
                return "IList<" + entityName + ">";
            default:
                throw new NotSupportedException("ResultSetKind not supported");
        }

    }
}
#>﻿<#+ 
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
void RoundDateJsonConverterGeneration_Render(DataLayerGeneration generation)
{
	bool generateRoundDateJsonConverter = generation.EntitySettings.Any(entity => entity.RoundDateFields != null);
	if (!generateRoundDateJsonConverter) return;
#>
namespace <#= generation.RootNamespace #>
{
    public class RoundDateJsonConverter : Newtonsoft.Json.Converters.DateTimeConverterBase
    {
        public override bool CanConvert(Type objectType)
        {
            return typeof(DateTime) == objectType || typeof(DateTime) == objectType;
        }

        public override object ReadJson(Newtonsoft.Json.JsonReader reader, Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer)
        {
            DateTime? result = null;
            if (reader.TokenType == Newtonsoft.Json.JsonToken.String)
            {
                string valueAsString = (string)reader.Value;
                DateTime? date = (DateTime?)Newtonsoft.Json.Linq.JToken.Parse("\"" + valueAsString + "\"");
                if (date.HasValue) result = date.Value.AddHours(12).Date;
            }
            else if (reader.TokenType == Newtonsoft.Json.JsonToken.Date)
            {
                result = ((DateTime)reader.Value).AddHours(12).Date;
            }
            if (result == null && objectType == typeof(DateTime)) return DateTime.MinValue;
            return result; 
        }

        public override void WriteJson(Newtonsoft.Json.JsonWriter writer, object value, Newtonsoft.Json.JsonSerializer serializer)
        {
            if (value == null)
            {
                writer.WriteNull();
            }
            else
            {
                DateTime date = ((DateTime)value).AddHours(12).Date;
                writer.WriteValue(date.ToString("yyyy-MM-dd"));
            }
        }
    }
}
<#+
}
#>﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public class Sequence
{
	public string SequenceSchema { get; set;}
	public string SequenceName { get; set;}

	public string FullSequenceName 
	{
		get
		{
			if (string.IsNullOrEmpty(SequenceSchema))
			{
				return SequenceName;
			}
			else
			{
				return SequenceSchema + "." + SequenceName;
			}
		}
	}
}
#>﻿<#+
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
public enum TextTransform
{
    None = 0,
    ToUnderscoreLowerCaseNamingConvention = 1,
    ToUnderscoreUpperCaseNamingConvention = 2,
    ToPascalNamingConvention = 4,
    ToLower = 8,
    ToUpper = 16
}
#>﻿<#+ 
/*
Copyright 2014 i-nercya intelligent software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
void TypeScriptAttributeGeneration_Render(DataLayerGeneration generation)
{
	bool generateTypeScript = generation.EntitySettings.Any(entity => entity.GenerateTypeScript.HasValue ? entity.GenerateTypeScript.Value : generation.GenerateTypeScript);
	if (!generateTypeScript) return;
#>
namespace <#= generation.RootNamespace #>
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum, AllowMultiple = false)]
    public partial class TypeScriptAttribute : Attribute
    {
        public static IEnumerable<Type> GetClasses()
        {
            var asm = System.Reflection.Assembly.GetExecutingAssembly();
            foreach (var t in asm.GetTypes().Where(x => x.IsClass))
            {
                var attrs = t.GetCustomAttributes(typeof(TypeScriptAttribute), false);
                if (attrs != null && attrs.Length > 0) yield return t;
            }
        }

        public static IEnumerable<Type> GetEnums()
        {
            var asm = System.Reflection.Assembly.GetExecutingAssembly();
            foreach (var t in asm.GetTypes().Where(x => x.IsEnum))
            {
                var attrs = t.GetCustomAttributes(typeof(TypeScriptAttribute), false);
                if (attrs != null && attrs.Length > 0) yield return t;
            }
        }
    }
}
<#+
}
#>